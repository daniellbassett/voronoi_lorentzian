//voronoi_lorentzian - Daniel Bassett, 2025
//--------------------------------------------------congruence_modules.m--------------------------------------------------
/*
TODO: write description
*/

import "init.m" : n, q;


//----------Coinduced module----------
/*For prime p, the coset space SO(n,1) / Gamma^0(p) has a model as the isotropic points in P^n(F_p)
We treat elements of the coinduced module as row vectors, indexed by these isotropic points.
Thus the coinduced_action_matrix A has a_ij = 1 when it takes basis vector i to basis vector j
*/

function projective_standard_form(v) //normalises so that the first non-zero coordinate is 1
	for i in [1..n+1] do
		if v[i] ne 0 then
			return v / v[i];
		end if;
	end for;
end function;

function coinduced_module(level) //calculates the projective standard forms of the isotropic points in P^n(F_p)	
	V_p := VectorSpace(level, n+1, DiagonalMatrix(level, n+1, [-q[i] : i in [1..n]] cat [1]));
	
	isotropic_points := [];
	for v in V_p do
		if v eq V_p ! 0 then
			continue;
		end if;
		
		if projective_standard_form(v) eq v then //take only one point on each line
			if Norm(v) eq 0 then
				Append(~isotropic_points, v);
			end if;
		end if;
	end for;
	
	return isotropic_points;
end function;

function module_action(level, isotropic_point, gamma) //calculates the action of a group element gamma on a point isotropic_point
	return projective_standard_form(isotropic_point * gamma);
end function;


//----------Invariants----------
function coinduced_action_matrix(level, module, gamma) //calculates a permutation matrix representing the action of gamma on the coinduced module
	M := MatrixRing(Rationals(), #module) ! 0;
	
	gamma_induced := MatrixRing(level, n+1) ! gamma;
	
	for i in [1..#module] do //find the image of the ith basis vector
		image_vector := module_action(level, module[i], gamma_induced);
		j := Index(module, image_vector);
		
		M[i,j] := 1;
	end for;
	
	return M;
end function;

function invariant_module(level, module, generators) //calculates the invariant submodule with respect to the group generated by generators
	V := VectorSpace(Rationals(), #module);
	
	for gamma in generators do
		gamma_matrix := coinduced_action_matrix(level, module, gamma);
		V := V meet Kernel(gamma_matrix - 1);
	end for;
	
	return V; //vector space automatically endowed with a basis
end function;

/*optimisation thoughts

for p=7:
    <main>                                               12.30       1       
39    coboundary_map                                       11.93       8       
27    coinduced_action_matrix                              10.45       6432    
28    module_action                                        5.83        1884374 
17    projective_standard_form                             4.17        1904577 
30    Index(<SeqEnum> S, <Any> x) -> RngIntElt             3.11        1884494 
29    *(<ModTupRngElt> v, <AlgMatElt> X) -> ModTupRngElt   1.63        1890670 


90% of the execution is spent in coinduced_action matrix
55% of that is spent in module action, which is 75% projective_standard_form and 25% matrix multiplication
most of the rest is found calculating the position of something inside a list


for p=11:
ndex Name                                                 Time        Count   
1     <main>                                               383.31      1       
39    coboundary_map                                       379.73      10      
27    coinduced_action_matrix                              281.91      20615   
30    Index(<SeqEnum> S, <Any> x) -> RngIntElt             140.94      22648436
29    *(<ModTupRngElt> v, <AlgMatElt> X) -> ModTupRngElt   90.10       22668731
28    module_action                                        87.15       22648286
17    projective_standard_form                             59.14       22829539
6     Constructor (sub)                                    6.01        22853361
19    /(<ModTupRngElt> u, <RngElt> c) -> ModTupRngElt      5.23        22829539
18    ne(<FldFinElt> x, <FldFinElt> y) -> BoolElt          4.07        25102319
5     +(<RngIntElt> x, <RngIntElt> y) -> RngIntElt         4.01        22854483

so seems like more and more time is spent calculating the index within a list :( hard to know what to do about that other than better algorithm/*
